# **Synchronization Strategies in ArgoCD**

Synchronization in ArgoCD refers to the process of aligning the live state of Kubernetes resources with the desired state defined in a Git repository. This section covers **Manual vs. Automatic Synchronization**, **Sync Options and Parameters**, and **Sync Waves and Hooks**.

---

## **Manual vs. Automatic Synchronization**

1. **Manual Synchronization**:
   - In manual mode, synchronization is triggered explicitly by an operator using the ArgoCD UI or CLI.
   - This approach provides greater control, allowing users to review changes before applying them.
   - It is commonly used in production environments where stability is critical, and changes must be carefully tested or approved.

   **Command Example**:
   ```bash
   argocd app sync 
   ```

2. **Automatic Synchronization**:
   - In automatic mode, ArgoCD continuously monitors the Git repository for changes and applies them to the Kubernetes cluster without manual intervention.
   - Useful for environments requiring rapid iteration, such as development or staging.
   - Additional options like `selfHeal` (auto-correct drift) and `prune` (delete resources not in Git) can be enabled.

   **Configuration Example**:
   ```yaml
   spec:
     syncPolicy:
       automated:
         prune: true
         selfHeal: true
   ```

**Summary**:
- **Manual Sync**: Triggered by an operator; suitable for controlled environments.
- **Automatic Sync**: Continuous monitoring; ideal for rapid iteration.
- **Use Cases**: Manual for production, automatic for development/staging.

---

## **Sync Options and Parameters**

ArgoCD provides several options to customize synchronization behavior.

Please refer to the documentation for further options: https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/

1. **Selective Sync**:
   - By default, all resources are synchronized during a sync operation.
   - The `ApplyOutOfSyncOnly=true` option allows ArgoCD to sync only out-of-sync resources, saving time and reducing API server load.

1. **Self-Healing**:
   - Automatically detects and corrects drift between live and desired states.
   - Enabled by setting `selfHeal: true` in the sync policy.

1. **Pruning Resources**:
   - Deletes resources from the cluster if they are no longer defined in Git.
   - Controlled with the `prune` option.

1. **Skipping Dry Run**:
   - For custom resource definitions (CRDs) not yet registered in the cluster, use `SkipDryRunOnMissingResource=true` to bypass validation.

1. **Fail on Shared Resources**:
   - Prevents syncing if a resource is already managed by another application using `FailOnSharedResource=true`.

1. **Server-Side Apply**:
   - Like the usual `kubectl apply --server-side` option

**Example Configuration**:
```yaml
spec:
  syncPolicy:
    syncOptions:
      - ApplyOutOfSyncOnly=true
      - RespectIgnoreDifferences=true
      - SkipDryRunOnMissingResource=true
```

**Summary**:
- **Selective Sync**: Sync only out-of-sync resources.
- **Self-Healing**: Auto-correct drift between live and desired states.
- **Pruning Resources**: Remove unused resources from the cluster.
- **Skip Dry Run**: Bypass validation for missing CRDs.

---

## **Sync Waves and Hooks**

Refer for more detailed explanation to the documentation: https://argo-cd.readthedocs.io/en/latest/user-guide/sync-waves/

1. **Sync Waves**:
   - Sync waves define the order in which resources are synchronized during a single operation.
   - Resources are assigned numeric wave values using annotations. Lower values (e.g., `-10`) are synced first, while higher values (e.g., `10`) are synced later.
   - Default wave value is `0`.

   **Example Annotation for Sync Wave**:
   ```yaml
   metadata:
     annotations:
       argocd.argoproj.io/sync-wave: "-10"
   ```

2. **Phases of Synchronization**:
   - ArgoCD divides synchronization into three phases:
     - *Pre-Sync*: Tasks executed before applying manifests (e.g., database setup).
     - *Sync*: Default phase where most resources are applied.
     - *Post-Sync*: Tasks executed after manifests are applied (e.g., running tests).

3. **Hooks**:
   - Hooks allow you to run custom logic during specific phases of synchronization (e.g., pre-sync, post-sync).
   - Common use cases include database migrations or cleanup tasks.

   **Example Hook Definition**:
   ```yaml
   apiVersion: batch/v1
   kind: Job
   metadata:
     annotations:
       argocd.argoproj.io/hook: PreSync
       argocd.argoproj.io/sync-wave: "-5"
   ```

4. **Execution Order**:
   - Resources are synchronized in this order: 
     1. Phase (Pre-Sync → Sync → Post-Sync)
     2. Wave value (negative → zero → positive)
     3. Resource kind (alphabetical)
     4. Resource name (alphabetical)

**Summary**:
- **Sync Waves**: Define resource sync order using numeric annotations.
- **Phases of Syncing**: Pre-Sync → Sync → Post-Sync.
- **Hooks**: Run custom tasks during specific phases.
- **Execution Order**: Phase → Wave → Kind → Name.

---

## Final Notes

These synchronization strategies provide flexibility in managing deployments with ArgoCD, ensuring that complex dependencies are handled efficiently while maintaining consistency between live and desired states.
